{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Arial;}}\par
{\*\generator FinalProject Documentation}\viewkind4\uc1 \par
\pard\sa200\sl276\slmult1\f0\fs22\lang1033\par
\par
{\b\fs32 Comprehensive Documentation - Clothing Store Network Management System\par}\par
\par\par
\par
{\b\fs24 Part 1: Overview\par}\par
\par\par
\par
{\b System Purpose:\par}\par
A clothing store network management system that enables inventory management, customers, employees, sales, reports, and inter-branch chat. The system is built on a Client-Server architecture with a graphical user interface (GUI) based on Swing.\par
\par\par\par
\par
{\b General Architecture:\par}\par
The system is based on a classic Client-Server architecture:\par
\par\par
- {\b Server:} Java server listening on port 5000, handling each client in a separate Thread (Thread-per-Client)\par
\par\par
- {\b Client:} Swing application connected to the server via Socket\par
\par\par
- {\b Communication:} Simple text protocol with commands separated by ";"\par
\par\par
- {\b Data Storage:} JSON files in the data/ directory\par
\par\par\par
\par
{\b Design Patterns:\par}\par
1. {\b MVC (Model-View-Controller):} Separation between data model (model/), user interface (gui/), and business logic (controller/)\par
\par\par
2. {\b Manager Pattern:} Manager classes (CustomerManager, ProductManager, etc.) manage business logic and data\par
\par\par
3. {\b Factory Pattern:} CustomerManager creates different types of customers (NewCustomer, ReturningCustomer, VipCustomer) based on a parameter\par
\par\par
4. {\b Queue Pattern (Producer-Consumer):} ChatManager uses LinkedBlockingQueue to manage chat request queue (FIFO)\par
\par\par
5. {\b DTO Pattern (Data Transfer Objects):} *Data classes (CustomerData, EmployeeData, etc.) for data transfer between layers\par
\par\par
6. {\b Template Method Pattern:} Customer class is abstract with abstract calculatePrice() - each customer type implements its own calculation\par
\par\par\par
\par
{\b Technologies:\par}\par
- Java (JDK 8+)\par
- Swing (GUI)\par
- Socket Programming (java.net.Socket)\par
- Manual JSON Serialization (no external libraries)\par
- Manual RTF Export (no external libraries)\par
\par\par\par
\par
{\b\fs24 Part 2: Directory and File Structure\par}\par
\par\par
\par
{\b src/ directory:\par}\par
The main directory containing all source code.\par
\par\par\par
\par
{\b src/model/ directory:\par}\par
Contains the data model and business logic.\par
\par\par
{\b Base Classes:}\par
\par\par
- {\b Customer.java:} Abstract class representing a customer. Contains fullName, idNumber, phone. Abstract method calculatePrice() - each customer type calculates price differently (Template Method Pattern).\par
\par\par
- {\b NewCustomer.java:} New customer - returns full price (no discount).\par
\par\par
- {\b ReturningCustomer.java:} Returning customer - returns price with 5% discount (basePrice * 0.95).\par
\par\par
- {\b VipCustomer.java:} VIP customer - returns price with 15% discount (basePrice * 0.85).\par
\par\par
- {\b Product.java:} Represents a product - productId, name, category, price, active. equals() and hashCode() based on productId.\par
\par\par
- {\b Employee.java:} Represents an employee - fullName, idNumber, phone, bankAccount, employeeNumber, role, branchId, active.\par
\par\par
- {\b Sale.java:} Represents a sale - product, quantity, branchId, employeeNumber, customerId, dateTime, basePrice, finalPrice.\par
\par\par
- {\b Branch.java:} Represents a branch - branchId, Inventory. Each branch has its own inventory.\par
\par\par
- {\b Inventory.java:} Manages branch inventory - Map<Product, Integer>. Methods: addProduct(), sellProduct(), removeProduct(), getProductQuantity().\par
\par\par
- {\b User.java:} Represents a system user - username, password, employeeNumber, userType (ADMIN/EMPLOYEE), branchId, active, mustChangePassword.\par
\par\par
- {\b Session.java:} Represents an active session - username, employeeNumber, branchId, userType, socket, loginTime.\par
\par\par
- {\b LogEntry.java:} Represents a log entry - actionType, description, dateTime, chatId (optional).\par
\par\par
- {\b ReportEntry.java:} Represents a report row - branchId, productId, productName, category, quantity, totalRevenue, date.\par
\par\par\par
\par
{\b Chat Classes:}\par
\par\par
- {\b ChatSession.java:} Represents an active chat - chatId, Set<String> participants, startTime, SessionStatus (ACTIVE/ENDED). Methods: addParticipant(), removeParticipant(), hasParticipant(), end().\par
\par\par
- {\b ChatMessage.java:} Represents a chat message - chatId, senderUsername, message, timestamp, MessageType (TEXT/SYSTEM). toJson() method for JSON conversion.\par
\par\par
- {\b ChatRequest.java:} Represents a chat request in queue - requestId, requesterUsername, requesterBranchId, requestTime, RequestStatus (PENDING/MATCHED/CANCELLED).\par
\par\par
- {\b ChatUserStatus.java:} Enum - AVAILABLE, IN_CHAT, IN_QUEUE.\par
\par\par\par
\par
{\b src/model/exceptions/ directory:\par}\par
12 custom exception classes:\par
\par\par
- DuplicateCustomerException, DuplicateUserException, DuplicateEmployeeException\par
\par\par
- InvalidQuantityException, InsufficientStockException, InactiveProductException\par
\par\par
- InvalidCredentialsException, UserAlreadyLoggedInException, UnauthorizedException\par
\par\par
- WeakPasswordException, UserNotFoundException, EmployeeNotFoundException\par
\par\par
Each Exception is tailored to a specific situation and enables precise error handling.\par
\par\par\par
\par
{\b src/model/managers/ directory:\par}\par
10 Manager classes (Manager Pattern) - each manages a specific domain:\par
\par\par
- {\b CustomerManager:} Customer management - addCustomer(), updateCustomer(), deleteCustomer(), getCustomerById(), getAllCustomers(). Creates different customer types based on customerType (Factory Pattern).\par
\par\par
- {\b ProductManager:} Product management - getProduct() (creates if not exists), getExistingProduct(), getAllProducts(), addProductDirectly(), deleteProduct().\par
\par\par
- {\b InventoryManager:} Inventory management - addProduct(), sellProduct(), removeProduct(), getProductQuantity(). Works with Branch and Inventory.\par
\par\par
- {\b SalesManager:} Sales management - addSale(), getSales(). Maintains list of sales.\par
\par\par
- {\b LogManager:} Log management - addLog(), getLogs(). Maintains list of logs.\par
\par\par
- {\b BranchManager:} Branch management - addBranch(), getBranch(), getAllBranches(), getBranchIds(), loadBranches(). Creates B1 and B2 by default.\par
\par\par
- {\b AuthenticationManager:} Authentication management - authenticate(), createUser(), changePassword(), getUser(), userExists(), getAllUsers(), setUserActive(), deleteUser(). Creates admin and superadmin by default.\par
\par\par
- {\b EmployeeManager:} Employee management - addEmployee(), getEmployee(), getAllEmployees(), updateEmployee(), setEmployeeActive(), deleteEmployee(), getEmployeesByBranch(). Checks duplicates by employeeNumber and idNumber.\par
\par\par
- {\b SessionManager:} Session management - createSession() (checks not already logged in), removeSession(), getSession(), getSessionByUsername(), isUserLoggedIn(), getAllActiveSessions(). Uses ConcurrentHashMap for thread-safety.\par
\par\par
- {\b ChatManager:} Chat management - requestChat(), matchUsers() (FIFO), createChatSession(), addMessage(), endChat(), joinChatAsManager(), getUserStatus(), getChatHistory(), getUserChat(), cancelChatRequest(), getAllActiveChats(), canRequestChat(), getWaitingRequestsForBranch(), acceptChatRequest(). Uses LinkedBlockingQueue for request queue (Queue Pattern).\par
\par\par\par
\par
{\b src/controller/ directory:\par}\par
- {\b SystemController.java:} Central entry point - mediates between GUI/Server and Managers. Contains all Managers, loads and saves data, provides unified API for all operations. Methods: login(), logout(), addCustomer(), updateCustomer(), deleteCustomer(), addProduct(), sellProduct(), createUser(), createEmployee(), getSalesReportByBranch(), requestChat(), sendChatMessage(), endChat(), joinChatAsManager(), getAllLogs(), saveChatToRTF(), etc.\par
\par\par\par
\par
{\b src/server/ directory:\par}\par
- {\b ServerMain.java:} Server entry point - creates SystemController, listens on port 5000, creates new Thread for each client (Thread-per-Client).\par
\par\par
- {\b ClientHandler.java:} Handles each client separately - Runnable. Reads commands from client, routes to SystemController, sends responses. Handles LOGIN/LOGOUT, and all authenticated commands (ADD_CUSTOMER, SELL, REQUEST_CHAT, etc.). Handles exceptions and returns appropriate error messages.\par
\par\par\par
\par
{\b src/gui/ directory:\par}\par
- {\b LoginWindow.java:} Login window - username and password. Connects to server, sends LOGIN, opens MainWindow if successful.\par
\par\par
- {\b MainWindow.java:} Main window with JTabbedPane - contains 7 tabs: Customers, Products, Users (Admin only), Employees (Admin only), Logs (Admin only), Reports, Chat. Status bar with logout button.\par
\par\par
- {\b ClientConnection.java:} Server connection management - connect(), disconnect(), sendCommand(), login(), logout(), isConnected(). Uses Socket, BufferedReader, PrintWriter.\par
\par\par\par
\par
{\b src/gui/tabs/ directory:\par}\par
7 tabs:\par
\par\par
- {\b CustomersTab.java:} Display customers in table, add, edit, delete. Uses DefaultTableModel.\par
\par\par
- {\b ProductsTab.java:} Display products and inventory. For admin: internal tabs for each branch (B1, B2). For employee: only their branch. Add to inventory, sell, remove, delete product (Admin only).\par
\par\par
- {\b UsersManagementTab.java:} User management (Admin only) - create, update, deactivate, delete.\par
\par\par
- {\b EmployeesManagementTab.java:} Employee management (Admin only) - create, update, deactivate, delete.\par
\par\par
- {\b LogsTab.java:} Display logs (Admin only) - filter by type (All, Employee Registration, Customer Registration, Purchases/Sales, Chat Details). "Save Chat" button to save chat to RTF.\par
\par\par
- {\b ReportsTab.java:} Report buttons - sales by branch, product, category, daily. Opens ReportViewWindow.\par
\par\par
- {\b ChatTab.java:} Chat interface - waiting requests list, active chats, message area, send message. Buttons: Request Chat, Cancel Request, Accept Request, Join (Manager), End Chat. Auto-refresh every 3 seconds.\par
\par\par\par
\par
{\b src/gui/dialogs/ directory:\par}\par
9 dialogs for CRUD operations:\par
\par\par
- AddCustomerDialog, UpdateCustomerDialog\par
\par\par
- AddProductDialog, AddToInventoryDialog\par
\par\par
- CreateUserDialog, UpdateUserDialog\par
\par\par
- CreateEmployeeDialog, UpdateEmployeeDialog\par
\par\par
- SellProductDialog\par
\par\par\par
\par
{\b src/gui/windows/ directory:\par}\par
- {\b ReportViewWindow.java:} Window for displaying reports - table with data, "Export to Word" button (RTF). Manually parses JSON, creates RTF file with Hebrew support (Unicode escape).\par
\par\par\par
\par
{\b src/storage/ directory:\par}\par
- {\b StorageManager.java:} Save and load management - saveUsers(), loadUsers(), saveEmployees(), loadEmployees(), etc. Uses JsonSerializer.\par
\par\par
- {\b JsonSerializer.java:} Manual JSON conversion (no external libraries) - toJson(), fromJsonUsers(), fromJsonEmployees(), etc. Uses string manipulation and Regular Expressions for parsing.\par
\par\par
- {\b *Data.java:} DTO classes - CustomerData, EmployeeData, ProductData, SaleData, UserData. Conversion between Model and DTO (toCustomer(), toEmployee(), etc.).\par
\par\par\par
\par
{\b data/ directory:\par}\par
JSON files for data storage:\par
\par\par
- users.json, employees.json, customers.json, products.json, inventory.json, sales.json, logs.json, branches.json\par
\par\par\par
\par
{\b\fs24 Part 3: Detailed File Explanations\par}\par
\par\par
\par
{\b SystemController.java:\par}\par
{\b Purpose:} Central entry point - mediates between GUI/Server and Managers.\par
\par\par
{\b Instance variables:} All Managers (CustomerManager, InventoryManager, SalesManager, LogManager, ProductManager, BranchManager, AuthenticationManager, SessionManager, EmployeeManager, ChatManager), StorageManager.\par
\par\par
{\b Main methods:}\par
\par\par
- {\b loadAllData():} Loads all data from storage (users, employees, customers, products, branches, inventory, sales, logs).\par
\par\par
- {\b saveAllData():} Saves all data to storage.\par
\par\par
- {\b login():} User authentication, Session creation, log entry.\par
\par\par
- {\b logout():} Session removal, log entry.\par
\par\par
- {\b addCustomer():} Add customer via CustomerManager, log entry, save.\par
\par\par
- {\b sellProduct():} Sell product - retrieve product, branch, customer, sell from inventory, calculate price by customer type (polymorphism), create Sale, log entry.\par
\par\par
- {\b requestChat():} Chat request via ChatManager, log entry.\par
\par\par
- {\b sendChatMessage():} Send chat message, log entry.\par
\par\par
- {\b endChat():} End chat, log entry.\par
\par\par
- {\b joinChatAsManager():} Manager joins chat, log entry.\par
\par\par
- {\b getSalesReportByBranch():} Sales report by branch - collect sales, summarize by branchId.\par
\par\par
- {\b saveChatToRTF():} Save chat to RTF - collect logs and messages, create RTF file with Hebrew support.\par
\par\par
{\b Design decisions:} SystemController serves as Facade - provides unified and simple API, hides Manager complexity. Every operation includes logging and automatic saving.\par
\par\par\par
\par
{\b ChatManager.java:\par}\par
{\b Purpose:} Manages chat system - active chats, queues, user statuses.\par
\par\par
{\b Instance variables:}\par
\par\par
- activeChats: Map<String, ChatSession> - active chats\par
\par\par
- chatQueue: Queue<ChatRequest> - request queue (FIFO)\par
\par\par
- userStatus: Map<String, ChatUserStatus> - each user's status\par
\par\par
- pendingRequests: Map<String, ChatRequest> - pending requests\par
\par\par
- chatMessages: Map<String, List<ChatMessage>> - messages for each chat\par
\par\par
- userToChat: Map<String, String> - username -> chatId\par
\par\par
- waitingForUser: Map<String, Queue<ChatRequest>> - pending requests by branch\par
\par\par
{\b Main methods:}\par
\par\par
- {\b requestChat():} User requests chat - check if already in chat/queue, create ChatRequest, add to queue, attempt immediate match (matchUsers()), if not found - save to branch queue.\par
\par\par
- {\b matchUsers():} FIFO matching - takes first request in queue, finds available user from different branch, creates ChatSession, updates statuses, removes from queue.\par
\par\par
- {\b createChatSession():} Direct chat creation (without queue) - creates ChatSession, updates statuses.\par
\par\par
- {\b addMessage():} Add message to chat - check chat is active and user is participant, create ChatMessage, add to list.\par
\par\par
- {\b endChat():} End chat - update ChatSession to ENDED, update user statuses to AVAILABLE, attempt new matching.\par
\par\par
- {\b joinChatAsManager():} Manager joins - check user is manager (role=manager), add to participants, system message.\par
\par\par
- {\b acceptChatRequest():} User accepts request - find request in other branch's queue, create chat, update statuses.\par
\par\par
{\b Design decisions:} Queue Pattern (Producer-Consumer) - users request chat (Producer), matchUsers() searches for matches (Consumer). FIFO ensures fairness. ConcurrentHashMap and LinkedBlockingQueue for thread-safety.\par
\par\par\par
\par
{\b StorageManager.java + JsonSerializer.java:\par}\par
{\b Purpose:} Save and load data to/from JSON files.\par
\par\par
{\b StorageManager:} Manages JSON files - saveUsers(), loadUsers(), etc. Creates data/ directory if not exists.\par
\par\par
{\b JsonSerializer:} Manual JSON conversion without external libraries.\par
\par\par
{\b toJson():} Convert object to JSON - handles Map, List, String, Number, Boolean, Object (via toJsonObject()).\par
\par\par
{\b fromJson*():} Parse JSON - uses Regular Expressions and string manipulation. parseMap() and parseList() for parsing complex structures.\par
\par\par
{\b Design decisions:} Manual JSON Serialization instead of Gson/Jackson - no external dependencies, full control over format, simplicity. DTO Classes for separation of concerns - don't save passwords directly, control over fields.\par
\par\par\par
\par
{\b ClientHandler.java:\par}\par
{\b Purpose:} Handles each client separately - reads commands, routes to SystemController, sends responses.\par
\par\par
{\b Instance variables:} socket, controller, currentSession, isAuthenticated.\par
\par\par
{\b Main methods:}\par
\par\par
- {\b run():} Main loop - reads lines from client, calls handleCommand(), sends response.\par
\par\par
- {\b handleCommand():} Handles LOGIN/LOGOUT, routes other commands to handleAuthenticatedCommand().\par
\par\par
- {\b handleAuthenticatedCommand():} Switch on command - ADD_CUSTOMER, SELL, REQUEST_CHAT, etc. Each case routes to SystemController, returns response in format "OK;..." or "ERROR;...".\par
\par\par
{\b Communication protocol:} Commands separated by ";" - "COMMAND;param1;param2;...". Responses: "OK;..." or "ERROR;..." or "AUTH_ERROR;...".\par
\par\par
{\b Design decisions:} Thread-per-Client instead of NIO - simplicity, suitable for limited number of clients, easy to debug. Simple text protocol instead of JSON/XML - easy to read and debug.\par
\par\par\par
\par
{\b SessionManager.java:\par}\par
{\b Purpose:} Manages active sessions - prevents duplicate login.\par
\par\par
{\b Instance variables:} activeSessions (username -> Session), sessionsBySocket (socket -> Session).\par
\par\par
{\b Main methods:}\par
\par\par
- {\b createSession():} Create new session - check if user already logged in (activeSessions.containsKey()), if yes - throws UserAlreadyLoggedInException. Creates Session, adds to Maps.\par
\par\par
- {\b removeSession():} Remove session - remove from sessionsBySocket and activeSessions.\par
\par\par
- {\b getSession():} Retrieve session by socket.\par
\par\par
- {\b getSessionByUsername():} Retrieve session by username.\par
\par\par
{\b Design decisions:} ConcurrentHashMap for thread-safety - multiple Threads handle different clients. Two Maps - one by username (for quick check), one by socket (for retrieval by connection).\par
\par\par\par
\par
{\b Customer Classes (Template Method Pattern):\par}\par
{\b Customer.java:} Abstract class - fullName, idNumber, phone, calculatePrice() abstract.\par
\par\par
{\b NewCustomer.java:} calculatePrice() returns basePrice (no discount).\par
\par\par
{\b ReturningCustomer.java:} calculatePrice() returns basePrice * 0.95 (5% discount).\par
\par\par
{\b VipCustomer.java:} calculatePrice() returns basePrice * 0.85 (15% discount).\par
\par\par
{\b Design decisions:} Template Method Pattern - Customer defines structure (calculatePrice() abstract), each customer type implements its own calculation. Polymorphism - SystemController.sellProduct() calls customer.calculatePrice() without knowing specific type.\par
\par\par\par
\par
{\b\fs24 Part 4: Design Decisions and Explanations\par}\par
\par\par
\par
{\b 1. Manual JSON Serialization - Why not Gson/Jackson?\par}\par
{\b Decision:} Manual JSON Serialization without external libraries.\par
\par\par
{\b Reasons:}\par
\par\par
- No external dependencies - project stands on its own, no additional JARs needed\par
\par\par
- Full control over format - know exactly what is saved and how\par
\par\par
- Simplicity - don't need to learn external library API\par
\par\par
- Small size - no additional JARs\par
\par\par
{\b Disadvantages:} More complex code, less efficient, doesn't support all JSON features (complex nested objects).\par
\par\par\par
\par
{\b 2. Manager Pattern - Why not DAO or Repository?\par}\par
{\b Decision:} Manager Pattern - Manager classes manage business logic and data.\par
\par\par
{\b Reasons:}\par
\par\par
- Separation between business logic and data - Manager contains both logic (e.g., CustomerManager creates different customer types) and data\par
\par\par
- Easy to extend - adding new Manager is simple\par
\par\par
- Centralized state management - each Manager stores its data in a Map\par
\par\par
- Simplicity - no need for Interface or Abstract Class\par
\par\par
{\b Disadvantages:} Less flexible than Repository Pattern, difficult for testing (Unit Tests) because Managers depend on each other.\par
\par\par\par
\par
{\b 3. Thread-per-Client - Why not NIO or Thread Pool?\par}\par
{\b Decision:} Thread-per-Client - each client gets separate Thread.\par
\par\par
{\b Reasons:}\par
\par\par
- Simplicity - easy to understand and debug, each Thread handles one client\par
\par\par
- Suitable for limited number of clients - system designed for limited number of employees (not thousands of users)\par
\par\par
- Easy to debug - each Thread is independent, easy to track problems\par
\par\par
{\b Disadvantages:} Not suitable for large number of clients (each Thread consumes resources), less efficient than NIO.\par
\par\par\par
\par
{\b 4. ConcurrentHashMap - Why not synchronized?\par}\par
{\b Decision:} ConcurrentHashMap instead of synchronized blocks.\par
\par\par
{\b Reasons:}\par
\par\par
- Better performance - ConcurrentHashMap optimized for multi-threading, doesn't block entire Map\par
\par\par
- Thread-safe - ensures thread-safety without synchronized\par
\par\par
- Suitable for multi-threaded server - multiple Threads read and write simultaneously\par
\par\par
{\b Disadvantages:} Doesn't support complex operations (e.g., check-and-update) - needs external synchronization.\par
\par\par\par
\par
{\b 5. Queue Pattern for Chat - Why FIFO?\par}\par
{\b Decision:} LinkedBlockingQueue with FIFO (First In First Out).\par
\par\par
{\b Reasons:}\par
\par\par
- Fairness - first requester gets first\par
\par\par
- Simplicity - simple Queue, easy to understand\par
\par\par
- Meets requirements - explicit requirement for FIFO\par
\par\par
{\b Disadvantages:} Not suitable for all cases - sometimes Priority Queue is better (e.g., by priority).\par
\par\par\par
\par
{\b 6. DTO Classes - Why not serialize directly?\par}\par
{\b Decision:} DTO classes (CustomerData, EmployeeData, etc.) for conversion between Model and JSON.\par
\par\par
{\b Reasons:}\par
\par\par
- Separation of concerns - Model not dependent on storage format\par
\par\par
- Control over fields - choose what to save (e.g., don't save passwords directly)\par
\par\par
- Security - don't save sensitive information (passwords) or unnecessary data\par
\par\par
- Flexibility - easy to change storage format without changing Model\par
\par\par
{\b Disadvantages:} Additional code, need to maintain sync between Model and DTO.\par
\par\par\par
\par
{\b 7. Custom Exceptions - Why not RuntimeException?\par}\par
{\b Decision:} 12 custom exception classes.\par
\par\par
{\b Reasons:}\par
\par\par
- Type safety - each Exception represents specific situation, easy to handle\par
\par\par
- Mandatory handling - checked exceptions require handling (try-catch)\par
\par\par
- Cleaner code - don't need to check error codes or messages\par
\par\par
- Precise information - each Exception contains relevant information\par
\par\par
{\b Disadvantages:} Additional code, need to handle many exceptions.\par
\par\par\par
\par
{\b 8. Manual RTF Export - Why not Apache POI?\par}\par
{\b Decision:} Manual RTF creation without external libraries.\par
\par\par
{\b Reasons:}\par
\par\par
- No dependencies - no additional JARs needed\par
\par\par
- Hebrew support - RTF supports Unicode escape (\uXXXX?) for Hebrew\par
\par\par
- Simplicity - RTF is text format, easy to create\par
\par\par
- Small size - no additional JARs\par
\par\par
{\b Disadvantages:} Doesn't support all RTF features (complex tables, images), more complex code.\par
\par\par\par
\par
{\b 9. Template Method Pattern in Customer - Why not Strategy?\par}\par
{\b Decision:} Customer abstract with abstract calculatePrice() (Template Method).\par
\par\par
{\b Reasons:}\par
\par\par
- Simplicity - no need for Strategy interface or Context\par
\par\par
- Natural polymorphism - Customer is the customer type, no need for wrapper\par
\par\par
- Easy to extend - adding new customer type = new class\par
\par\par
{\b Disadvantages:} Less flexible than Strategy - cannot change algorithm at runtime.\par
\par\par\par
\par
{\b 10. Simple Text Protocol - Why not JSON/XML?\par}\par
{\b Decision:} Text protocol with commands separated by ";".\par
\par\par
{\b Reasons:}\par
\par\par
- Simplicity - easy to read and debug, no parser needed\par
\par\par
- Speed - no need to parse JSON/XML\par
\par\par
- Easy to implement - simple string manipulation\par
\par\par
{\b Disadvantages:} Doesn't support complex structures, not standard, difficult to extend.\par
\par\par\par
\par
{\b\fs24 Part 5: Diagrams\par}\par
\par\par
\par
{\b General Architecture Diagram:\par}\par
Client (Swing GUI) <--Socket--> Server (ServerMain) --> ClientHandler (Thread) --> SystemController --> Managers --> Model Classes\par
\par\par\par
\par
{\b Communication Diagram:\par}\par
Client: sendCommand("LOGIN;user;pass") --> Server: handleCommand() --> SystemController.login() --> Response: "LOGIN_SUCCESS;ADMIN;B1;EMP001" --> Client: handleLoginResponse()\par
\par\par\par
\par
{\b Chat Diagram (Queue Matching):\par}\par
User A (Branch 1) requests chat --> ChatManager.requestChat() --> Added to chatQueue --> matchUsers() finds User B (Branch 2) available --> Creates ChatSession --> Returns "OK;MATCHED;CHAT_123;userA;userB"\par
\par\par
If no match: Added to waitingForUser[Branch1] --> When User B becomes available: Gets notification --> acceptChatRequest() --> Creates ChatSession\par
\par\par\par
\par
{\b Save/Load Diagram:\par}\par
SystemController.saveAllData() --> StorageManager.saveUsers() --> JsonSerializer.toJson() --> Write to data/users.json\par
\par\par
SystemController.loadAllData() --> StorageManager.loadUsers() --> JsonSerializer.fromJsonUsers() --> Read from data/users.json --> Create User objects\par
\par\par\par
\par
{\b Customer Classes Inheritance Diagram:\par}\par
Customer (abstract) --> NewCustomer, ReturningCustomer, VipCustomer\par
\par\par
Customer: calculatePrice() abstract\par
\par\par
NewCustomer: calculatePrice() returns basePrice\par
\par\par
ReturningCustomer: calculatePrice() returns basePrice * 0.95\par
\par\par
VipCustomer: calculatePrice() returns basePrice * 0.85\par
\par\par\par
\par
{\b\fs24 Summary\par}\par
\par\par
\par
The system is built with clean and organized architecture with clear separation between layers. The use of design patterns (Manager, Factory, Template Method, Queue) ensures readable and maintainable code. Design decisions (Manual JSON, Thread-per-Client, ConcurrentHashMap, etc.) are suitable for the system's purpose - internal system for limited number of users, without external dependencies, with full control over the code.\par
\par\par\par
\par
{\b Total Files:\par}\par
- Model: ~25 files\par
- Managers: 10 files\par
- Exceptions: 12 files\par
- GUI: ~20 files\par
- Server: 2 files\par
- Storage: 7 files\par
- Controller: 1 file\par
\par\par
Total: ~77 Java files\par
\par\par\par
\par
}